The Factory Design Pattern is a creational design pattern that provides a way to create objects without specifying the exact class of object that will be created. 
The pattern provides an interface or abstract class for creating objects, and allows subclasses to decide which class to instantiate. 
This pattern helps to create objects in a more flexible and maintainable way, as it allows you to add new object types without having to change the existing code.

Here is an outline description of the Factory Design Pattern:

    Define a factory interface or abstract class that declares a method for creating objects.
    Create concrete classes that implement the factory interface or abstract class, each of which is responsible for creating a specific type of object.
    Define a client that uses the factory to create objects, without having to know the specific class of object being created.
    The client calls the factory method to create the object, which is returned as an interface or abstract class type.
    The client then uses the object without knowing the specific class type, as the factory has created the object based on the parameters passed in.

The Factory Design Pattern can be used in situations where the creation of objects needs to be centralized or delegated to specific classes, such as when creating objects that require complex setup, or when creating objects based on specific criteria or conditions.


#include <iostream>
#include <string>

// Abstract base class for products
class Product {
public:
    virtual ~Product() {}
    virtual std::string getName() = 0;
};

// Concrete product class 1
class ConcreteProduct1 : public Product {
public:
    std::string getName() override {
        return "Concrete Product 1";
    }
};

// Concrete product class 2
class ConcreteProduct2 : public Product {
public:
    std::string getName() override {
        return "Concrete Product 2";
    }
};

// Abstract factory class
class Factory {
public:
    virtual ~Factory() {}
    virtual Product* createProduct() = 0;
};

// Concrete factory class 1
class ConcreteFactory1 : public Factory {
public:
    Product* createProduct() override {
        return new ConcreteProduct1();
    }
};

// Concrete factory class 2
class ConcreteFactory2 : public Factory {
public:
    Product* createProduct() override {
        return new ConcreteProduct2();
    }
};

// Client code
int main() {
    // Create a ConcreteFactory1 object
    Factory* factory1 = new ConcreteFactory1();
    Factory* factory2 = new ConcreteFactory2();
    
    // Use the factory to create a product
    Product* product1 = factory1->createProduct();
    Product* product2 = factory2->createProduct();
    
    // Print the name of the product
    std::cout << product1->getName() << std::endl;
    std::cout << product2->getName() << std::endl;
    
    // Clean up
    delete product1;
    delete factory1;
    
    delete product2;
    delete factory2;
    
    return 0;
}


Run:

Concrete Product 1
Concrete Product 2


==========================================
In this example, we have an abstract base class Product and two concrete product classes ConcreteProduct1 and ConcreteProduct2 that implement the Product interface.

We also have an abstract factory class Factory and two concrete factory classes ConcreteFactory1 and ConcreteFactory2 that implement the Factory interface. Each factory is responsible for creating a specific type of product.

In the client code, we create a ConcreteFactory1 object and use it to create a product. We then print the name of the product and clean up the memory used by the product and factory objects.

This example shows how the Factory Design Pattern allows us to create objects without having to know the specific class type, as the factory is responsible for creating the object based on the parameters passed in.




